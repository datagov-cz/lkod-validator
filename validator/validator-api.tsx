/**
 * Listener to the process of validation. By default, ignores all
 * operations.
 */
import { Quad } from "@rdfjs/types";

export interface ValidationListener {
  onValidationWillStart(): void;

  /**
   * Called when status message is changed.
   */
  onStatus(status: string, args: object | undefined): void;

  /**
   * Called when resource validation will start.
   */
  onResourceWillStart(resource: ResourceInValidation): void;

  /**
   * Report as what type the resource is validated.
   */
  onContentType(
    resource: ResourceInValidation,
    type: ResourceContentType
  ): void;

  /**
   * Called when validator emits new message.
   */
  onMessage(resource: ResourceInValidation, message: Message): void;

  /**
   * Called then RDF content is ready.
   */
  onRdfContent(resource: ResourceInValidation, quads: Quad[]): void;

  /**
   * Called when resource validation  ended.
   */
  onResourceDidEnd(resource: ResourceInValidation): void;

  onValidationDidEnd(): void;
}

export function createNoActionValidationListener(): ValidationListener {
  return {
    onValidationWillStart(): void {
      // No action.
    },
    onStatus(status: string, args: object | undefined): void {
      // No action.
    },
    onResourceWillStart(resource: ResourceInValidation): void {
      // No action.
    },
    onContentType(
      resource: ResourceInValidation,
      type: ResourceContentType
    ): void {
      // No action.
    },
    onMessage(resource: ResourceInValidation, message: Message): void {
      // No action.
    },
    onRdfContent(resource: ResourceInValidation, quads: Quad[]): void {
      // No action.
    },
    onResourceDidEnd(resource: ResourceInValidation): void {
      // No action.
    },
    onValidationDidEnd(): void {
      // No action.
    },
  };
}

/**
 * Represent a basic validation unit a message.
 */
export interface Message {
  /**
   * Identify specific message types.
   */
  readonly type?: number;

  readonly created: Date;

  readonly level: Level;

  readonly validator: string;

  /**
   * Can use {{place-holder}} for values from args.
   */
  readonly message: string;

  readonly args: object | undefined;
}

/**
 * Message levels.
 */
export enum Level {
  /**
   * Information or positive validation outcome.
   */
  INFO = 0,
  /**
   * Something that may or may not be a problem.
   */
  WARNING = 1,
  /**
   * A problem.
   */
  ERROR = 2,
  /**
   * A problem that force us to stop validation of curren resource.
   */
  CRITICAL = 3,
}

/**
 * Represent a resource for validation.
 */
export class ResourceInValidation {
  /**
   * Resource URL.
   */
  url: string;
  /**
   * Resource is validated as this type.
   */
  type: ResourceType;

  constructor(url: string, type: ResourceType) {
    this.url = url;
    this.type = type;
  }
}

export enum ResourceType {
  /**
   * URL to validate as provided by the user.
   */
  URL = "URL",
  /**
   * Represent a catalog.
   */
  CATALOG = "CATALOG",
  /**
   * Dataset to validate.
   */
  DATASET = "DATASET",
}

export enum ResourceContentType {
  SPARQL = "SPARQL",
  JSONLD = "JSONLD",
  TURTLE = "TURTLE",
}

/**
 * Represent a full object generated by validation.
 * The report is build using messaged that a client can listen
 * to using {@link ValidationListener}.
 */
export class ValidationReporter {
  private readonly observers: ValidationListener[];

  private resources: ResourceInValidation[] = [];

  constructor(observers: ValidationListener[]) {
    this.observers = [
      //new WriteToConsoleListener(),
      ...observers,
    ];
  }

  validationBegin() {
    this.observers.forEach(observer => observer.onValidationWillStart());
  }

  validationEnd() {
    this.observers.forEach(observer => observer.onValidationDidEnd());
  }

  private emitMessage(
    level: Level,
    validator: string,
    message: string,
    args: object
  ): void {
    const messageObject: Message = {
      created: new Date(),
      level: level,
      validator: validator,
      message: message,
      args: args,
    };
    const resource = this.activeResource();
    this.observers.forEach(observer =>
      observer.onMessage(resource, messageObject)
    );
  }

  private activeResource(): ResourceInValidation {
    return this.resources[this.resources.length - 1];
  }

  info(validator: string, message: string, args: object = undefined): void {
    this.emitMessage(Level.INFO, validator, message, args);
  }

  warning(validator: string, message: string, args: object = undefined): void {
    this.emitMessage(Level.WARNING, validator, message, args);
  }

  error(validator: string, message: string, args: object = undefined): void {
    this.emitMessage(Level.ERROR, validator, message, args);
  }

  /**
   * Throws an exception to terminate validation.
   */
  critical(validator: string, message: string, args: object = undefined): void {
    this.emitMessage(Level.CRITICAL, validator, message, args);
  }

  updateStatus(status: string, args: object | undefined = undefined) {
    this.observers.forEach(observer => observer.onStatus(status, args));
  }

  beginUrlValidation(url: string) {
    this.openResource(new ResourceInValidation(url, ResourceType.URL));
  }

  private openResource(resource: ResourceInValidation): void {
    this.observers.forEach(observer => observer.onResourceWillStart(resource));
    this.resources.push(resource);
  }

  beginCatalogValidation(url: string) {
    this.openResource(new ResourceInValidation(url, ResourceType.CATALOG));
  }

  beginDatasetValidation(url: string) {
    this.openResource(new ResourceInValidation(url, ResourceType.DATASET));
  }

  endResourceValidation() {
    const resource = this.resources.pop();
    this.observers.forEach(observer => observer.onResourceDidEnd(resource));
  }

  contentType(type: ResourceContentType) {
    const resource = this.resources[this.resources.length - 1];
    this.observers.forEach(observer => observer.onContentType(resource, type));
  }

  contentAsRdf(quads: Quad[]) {
    const resource = this.resources[this.resources.length - 1];
    this.observers.forEach(observer => observer.onRdfContent(resource, quads));
  }
}

/**
 * Implementation of observer that longs into a console.
 */
class WriteToConsoleListener implements ValidationListener {
  onValidationWillStart() {
    // No action.
  }

  onStatus(status: string, args: object | undefined): void {
    console.log("   onStatus", status, args);
  }

  onResourceWillStart(resource: ResourceInValidation): void {
    console.log("onResourceWillStart", resource);
  }

  onContentType(
    resource: ResourceInValidation,
    type: ResourceContentType
  ): void {
    console.log("   onContentType", type);
  }

  onMessage(resource: ResourceInValidation, message: Message): void {
    console.log("   onMessage", message.validator, message.message);
  }

  onRdfContent(resource: ResourceInValidation, quads: Quad[]): void {
    console.log("   onRdfContent", quads);
  }

  onResourceDidEnd(resource: ResourceInValidation): void {
    console.log("onResourceDidEnd", resource);
  }

  onValidationDidEnd() {
    // No action.
  }
}
